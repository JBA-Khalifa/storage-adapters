{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":27792,"byte_end":27796,"line_start":801,"line_end":801,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":12,"highlight_end":16}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":27789,"byte_end":27796,"line_start":801,"line_end":801,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":27789,"byte_end":27796,"line_start":801,"line_end":801,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:801:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m801\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m801\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if BitMemory::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m801\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if IsNumber::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":27799,"byte_end":27811,"line_start":801,"line_end":801,"column_start":19,"column_end":31,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":19,"highlight_end":31}],"label":"expected type parameter `M`, found `u8`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":26344,"byte_end":26345,"line_start":765,"line_end":765,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"\tfn load_le<M>(&self) -> M","highlight_start":13,"highlight_end":14}],"label":"this type parameter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected type parameter `M`\n             found type `u8`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:801:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m765\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    fn load_le<M>(&self) -> M\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis type parameter\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m801\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type parameter `M`, found `u8`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected type parameter `\u001b[0m\u001b[0m\u001b[1mM\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m                         found type `\u001b[0m\u001b[0m\u001b[1mu8\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":27980,"byte_end":27984,"line_start":809,"line_end":809,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS - shamt {","highlight_start":12,"highlight_end":16}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":27977,"byte_end":27984,"line_start":809,"line_end":809,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS - shamt {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":27977,"byte_end":27984,"line_start":809,"line_end":809,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS - shamt {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:809:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m809\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > T::Mem::BITS - shamt {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m809\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if BitMemory::BITS > T::Mem::BITS - shamt {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m809\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if IsNumber::BITS > T::Mem::BITS - shamt {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":27987,"byte_end":28007,"line_start":809,"line_end":809,"column_start":19,"column_end":39,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS - shamt {","highlight_start":19,"highlight_end":39}],"label":"expected type parameter `M`, found `u8`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":26344,"byte_end":26345,"line_start":765,"line_end":765,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"\tfn load_le<M>(&self) -> M","highlight_start":13,"highlight_end":14}],"label":"this type parameter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected type parameter `M`\n             found type `u8`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:809:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m765\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    fn load_le<M>(&self) -> M\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis type parameter\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m809\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > T::Mem::BITS - shamt {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type parameter `M`, found `u8`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected type parameter `\u001b[0m\u001b[0m\u001b[1mM\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m                         found type `\u001b[0m\u001b[0m\u001b[1mu8\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":30265,"byte_end":30269,"line_start":885,"line_end":885,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":12,"highlight_end":16}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":30262,"byte_end":30269,"line_start":885,"line_end":885,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":30262,"byte_end":30269,"line_start":885,"line_end":885,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:885:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m885\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m885\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if BitMemory::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m885\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if IsNumber::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":30272,"byte_end":30284,"line_start":885,"line_end":885,"column_start":19,"column_end":31,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":19,"highlight_end":31}],"label":"expected type parameter `M`, found `u8`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":29795,"byte_end":29796,"line_start":868,"line_end":868,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"\tfn load_be<M>(&self) -> M","highlight_start":13,"highlight_end":14}],"label":"this type parameter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected type parameter `M`\n             found type `u8`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:885:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m868\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    fn load_be<M>(&self) -> M\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis type parameter\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m885\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type parameter `M`, found `u8`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected type parameter `\u001b[0m\u001b[0m\u001b[1mM\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m                         found type `\u001b[0m\u001b[0m\u001b[1mu8\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":30453,"byte_end":30457,"line_start":893,"line_end":893,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > shamt {","highlight_start":12,"highlight_end":16}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":30450,"byte_end":30457,"line_start":893,"line_end":893,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > shamt {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":30450,"byte_end":30457,"line_start":893,"line_end":893,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > shamt {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:893:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m893\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > shamt {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m893\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if BitMemory::BITS > shamt {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m893\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if IsNumber::BITS > shamt {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":30460,"byte_end":30465,"line_start":893,"line_end":893,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > shamt {","highlight_start":19,"highlight_end":24}],"label":"expected type parameter `M`, found `u8`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":29795,"byte_end":29796,"line_start":868,"line_end":868,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"\tfn load_be<M>(&self) -> M","highlight_start":13,"highlight_end":14}],"label":"this type parameter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected type parameter `M`\n             found type `u8`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:893:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m868\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    fn load_be<M>(&self) -> M\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis type parameter\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m893\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > shamt {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type parameter `M`, found `u8`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected type parameter `\u001b[0m\u001b[0m\u001b[1mM\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m                         found type `\u001b[0m\u001b[0m\u001b[1mu8\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":32176,"byte_end":32180,"line_start":944,"line_end":944,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS - shamt {","highlight_start":12,"highlight_end":16}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":32173,"byte_end":32180,"line_start":944,"line_end":944,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS - shamt {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":32173,"byte_end":32180,"line_start":944,"line_end":944,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS - shamt {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:944:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m944\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > T::Mem::BITS - shamt {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m944\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if BitMemory::BITS > T::Mem::BITS - shamt {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m944\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if IsNumber::BITS > T::Mem::BITS - shamt {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":32183,"byte_end":32203,"line_start":944,"line_end":944,"column_start":19,"column_end":39,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS - shamt {","highlight_start":19,"highlight_end":39}],"label":"expected type parameter `M`, found `u8`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":31750,"byte_end":31751,"line_start":932,"line_end":932,"column_start":14,"column_end":15,"is_primary":false,"text":[{"text":"\tfn store_le<M>(&mut self, mut value: M)","highlight_start":14,"highlight_end":15}],"label":"this type parameter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected type parameter `M`\n             found type `u8`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:944:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m932\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    fn store_le<M>(&mut self, mut value: M)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis type parameter\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m944\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > T::Mem::BITS - shamt {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type parameter `M`, found `u8`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected type parameter `\u001b[0m\u001b[0m\u001b[1mM\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m                         found type `\u001b[0m\u001b[0m\u001b[1mu8\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":32383,"byte_end":32387,"line_start":954,"line_end":954,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":12,"highlight_end":16}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":32380,"byte_end":32387,"line_start":954,"line_end":954,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":32380,"byte_end":32387,"line_start":954,"line_end":954,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:954:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m954\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m954\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if BitMemory::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m954\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if IsNumber::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":32390,"byte_end":32402,"line_start":954,"line_end":954,"column_start":19,"column_end":31,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":19,"highlight_end":31}],"label":"expected type parameter `M`, found `u8`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":31750,"byte_end":31751,"line_start":932,"line_end":932,"column_start":14,"column_end":15,"is_primary":false,"text":[{"text":"\tfn store_le<M>(&mut self, mut value: M)","highlight_start":14,"highlight_end":15}],"label":"this type parameter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected type parameter `M`\n             found type `u8`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:954:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m932\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    fn store_le<M>(&mut self, mut value: M)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis type parameter\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m954\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type parameter `M`, found `u8`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected type parameter `\u001b[0m\u001b[0m\u001b[1mM\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m                         found type `\u001b[0m\u001b[0m\u001b[1mu8\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":34104,"byte_end":34108,"line_start":1003,"line_end":1003,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > shamt {","highlight_start":12,"highlight_end":16}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":34101,"byte_end":34108,"line_start":1003,"line_end":1003,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > shamt {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":34101,"byte_end":34108,"line_start":1003,"line_end":1003,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > shamt {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:1003:12\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1003\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > shamt {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1003\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if BitMemory::BITS > shamt {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1003\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if IsNumber::BITS > shamt {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":34111,"byte_end":34116,"line_start":1003,"line_end":1003,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > shamt {","highlight_start":19,"highlight_end":24}],"label":"expected type parameter `M`, found `u8`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":33682,"byte_end":33683,"line_start":991,"line_end":991,"column_start":14,"column_end":15,"is_primary":false,"text":[{"text":"\tfn store_be<M>(&mut self, mut value: M)","highlight_start":14,"highlight_end":15}],"label":"this type parameter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected type parameter `M`\n             found type `u8`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:1003:19\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m991\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    fn store_be<M>(&mut self, mut value: M)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis type parameter\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1003\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > shamt {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type parameter `M`, found `u8`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected type parameter `\u001b[0m\u001b[0m\u001b[1mM\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m                          found type `\u001b[0m\u001b[0m\u001b[1mu8\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":34287,"byte_end":34291,"line_start":1013,"line_end":1013,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":12,"highlight_end":16}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":34284,"byte_end":34291,"line_start":1013,"line_end":1013,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":34284,"byte_end":34291,"line_start":1013,"line_end":1013,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:1013:12\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1013\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1013\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if BitMemory::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1013\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if IsNumber::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":34294,"byte_end":34306,"line_start":1013,"line_end":1013,"column_start":19,"column_end":31,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":19,"highlight_end":31}],"label":"expected type parameter `M`, found `u8`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":33682,"byte_end":33683,"line_start":991,"line_end":991,"column_start":14,"column_end":15,"is_primary":false,"text":[{"text":"\tfn store_be<M>(&mut self, mut value: M)","highlight_start":14,"highlight_end":15}],"label":"this type parameter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected type parameter `M`\n             found type `u8`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:1013:19\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m991\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    fn store_be<M>(&mut self, mut value: M)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis type parameter\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1013\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type parameter `M`, found `u8`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected type parameter `\u001b[0m\u001b[0m\u001b[1mM\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m                          found type `\u001b[0m\u001b[0m\u001b[1mu8\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":36708,"byte_end":36712,"line_start":1101,"line_end":1101,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":12,"highlight_end":16}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":36705,"byte_end":36712,"line_start":1101,"line_end":1101,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":36705,"byte_end":36712,"line_start":1101,"line_end":1101,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:1101:12\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if BitMemory::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if IsNumber::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":36715,"byte_end":36727,"line_start":1101,"line_end":1101,"column_start":19,"column_end":31,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":19,"highlight_end":31}],"label":"expected type parameter `M`, found `u8`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":36175,"byte_end":36176,"line_start":1079,"line_end":1079,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"\tfn load_le<M>(&self) -> M","highlight_start":13,"highlight_end":14}],"label":"this type parameter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected type parameter `M`\n             found type `u8`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:1101:19\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1079\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    fn load_le<M>(&self) -> M\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis type parameter\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type parameter `M`, found `u8`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected type parameter `\u001b[0m\u001b[0m\u001b[1mM\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m                          found type `\u001b[0m\u001b[0m\u001b[1mu8\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":36911,"byte_end":36915,"line_start":1109,"line_end":1109,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > shamt {","highlight_start":12,"highlight_end":16}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":36908,"byte_end":36915,"line_start":1109,"line_end":1109,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > shamt {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":36908,"byte_end":36915,"line_start":1109,"line_end":1109,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > shamt {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:1109:12\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > shamt {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if BitMemory::BITS > shamt {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if IsNumber::BITS > shamt {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":36918,"byte_end":36923,"line_start":1109,"line_end":1109,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > shamt {","highlight_start":19,"highlight_end":24}],"label":"expected type parameter `M`, found `u8`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":36175,"byte_end":36176,"line_start":1079,"line_end":1079,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"\tfn load_le<M>(&self) -> M","highlight_start":13,"highlight_end":14}],"label":"this type parameter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected type parameter `M`\n             found type `u8`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:1109:19\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1079\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    fn load_le<M>(&self) -> M\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis type parameter\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1109\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > shamt {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type parameter `M`, found `u8`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected type parameter `\u001b[0m\u001b[0m\u001b[1mM\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m                          found type `\u001b[0m\u001b[0m\u001b[1mu8\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":39162,"byte_end":39166,"line_start":1186,"line_end":1186,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":12,"highlight_end":16}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":39159,"byte_end":39166,"line_start":1186,"line_end":1186,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":39159,"byte_end":39166,"line_start":1186,"line_end":1186,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:1186:12\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1186\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1186\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if BitMemory::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1186\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if IsNumber::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":39169,"byte_end":39181,"line_start":1186,"line_end":1186,"column_start":19,"column_end":31,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":19,"highlight_end":31}],"label":"expected type parameter `M`, found `u8`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":38687,"byte_end":38688,"line_start":1168,"line_end":1168,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"\tfn load_be<M>(&self) -> M","highlight_start":13,"highlight_end":14}],"label":"this type parameter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected type parameter `M`\n             found type `u8`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:1186:19\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1168\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    fn load_be<M>(&self) -> M\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis type parameter\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1186\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type parameter `M`, found `u8`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected type parameter `\u001b[0m\u001b[0m\u001b[1mM\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m                          found type `\u001b[0m\u001b[0m\u001b[1mu8\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":39350,"byte_end":39354,"line_start":1194,"line_end":1194,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > shamt {","highlight_start":12,"highlight_end":16}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":39347,"byte_end":39354,"line_start":1194,"line_end":1194,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > shamt {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":39347,"byte_end":39354,"line_start":1194,"line_end":1194,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > shamt {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:1194:12\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1194\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > shamt {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1194\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if BitMemory::BITS > shamt {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1194\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if IsNumber::BITS > shamt {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":39357,"byte_end":39362,"line_start":1194,"line_end":1194,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > shamt {","highlight_start":19,"highlight_end":24}],"label":"expected type parameter `M`, found `u8`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":38687,"byte_end":38688,"line_start":1168,"line_end":1168,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"\tfn load_be<M>(&self) -> M","highlight_start":13,"highlight_end":14}],"label":"this type parameter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected type parameter `M`\n             found type `u8`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:1194:19\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1168\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    fn load_be<M>(&self) -> M\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis type parameter\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1194\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > shamt {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type parameter `M`, found `u8`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected type parameter `\u001b[0m\u001b[0m\u001b[1mM\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m                          found type `\u001b[0m\u001b[0m\u001b[1mu8\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":41154,"byte_end":41158,"line_start":1252,"line_end":1252,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > shamt {","highlight_start":12,"highlight_end":16}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":41151,"byte_end":41158,"line_start":1252,"line_end":1252,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > shamt {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":41151,"byte_end":41158,"line_start":1252,"line_end":1252,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > shamt {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:1252:12\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1252\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > shamt {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1252\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if BitMemory::BITS > shamt {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1252\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if IsNumber::BITS > shamt {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":41161,"byte_end":41166,"line_start":1252,"line_end":1252,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > shamt {","highlight_start":19,"highlight_end":24}],"label":"expected type parameter `M`, found `u8`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":40692,"byte_end":40693,"line_start":1237,"line_end":1237,"column_start":14,"column_end":15,"is_primary":false,"text":[{"text":"\tfn store_le<M>(&mut self, mut value: M)","highlight_start":14,"highlight_end":15}],"label":"this type parameter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected type parameter `M`\n             found type `u8`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:1252:19\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1237\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    fn store_le<M>(&mut self, mut value: M)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis type parameter\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1252\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > shamt {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type parameter `M`, found `u8`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected type parameter `\u001b[0m\u001b[0m\u001b[1mM\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m                          found type `\u001b[0m\u001b[0m\u001b[1mu8\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":41331,"byte_end":41335,"line_start":1262,"line_end":1262,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":12,"highlight_end":16}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":41328,"byte_end":41335,"line_start":1262,"line_end":1262,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":41328,"byte_end":41335,"line_start":1262,"line_end":1262,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:1262:12\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1262\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1262\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if BitMemory::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1262\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if IsNumber::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":41338,"byte_end":41350,"line_start":1262,"line_end":1262,"column_start":19,"column_end":31,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":19,"highlight_end":31}],"label":"expected type parameter `M`, found `u8`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":40692,"byte_end":40693,"line_start":1237,"line_end":1237,"column_start":14,"column_end":15,"is_primary":false,"text":[{"text":"\tfn store_le<M>(&mut self, mut value: M)","highlight_start":14,"highlight_end":15}],"label":"this type parameter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected type parameter `M`\n             found type `u8`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:1262:19\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1237\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    fn store_le<M>(&mut self, mut value: M)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis type parameter\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1262\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type parameter `M`, found `u8`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected type parameter `\u001b[0m\u001b[0m\u001b[1mM\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m                          found type `\u001b[0m\u001b[0m\u001b[1mu8\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":43162,"byte_end":43166,"line_start":1323,"line_end":1323,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > tail.value() {","highlight_start":12,"highlight_end":16}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":43159,"byte_end":43166,"line_start":1323,"line_end":1323,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > tail.value() {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":43159,"byte_end":43166,"line_start":1323,"line_end":1323,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > tail.value() {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:1323:12\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1323\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > tail.value() {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1323\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if BitMemory::BITS > tail.value() {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1323\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if IsNumber::BITS > tail.value() {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":43169,"byte_end":43181,"line_start":1323,"line_end":1323,"column_start":19,"column_end":31,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > tail.value() {","highlight_start":19,"highlight_end":31}],"label":"expected type parameter `M`, found `u8`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":42688,"byte_end":42689,"line_start":1304,"line_end":1304,"column_start":14,"column_end":15,"is_primary":false,"text":[{"text":"\tfn store_be<M>(&mut self, mut value: M)","highlight_start":14,"highlight_end":15}],"label":"this type parameter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected type parameter `M`\n             found type `u8`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:1323:19\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1304\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    fn store_be<M>(&mut self, mut value: M)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis type parameter\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1323\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > tail.value() {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type parameter `M`, found `u8`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected type parameter `\u001b[0m\u001b[0m\u001b[1mM\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m                          found type `\u001b[0m\u001b[0m\u001b[1mu8\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":43359,"byte_end":43363,"line_start":1333,"line_end":1333,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":12,"highlight_end":16}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":43356,"byte_end":43363,"line_start":1333,"line_end":1333,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":43356,"byte_end":43363,"line_start":1333,"line_end":1333,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:1333:12\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1333\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1333\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if BitMemory::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1333\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if IsNumber::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":43366,"byte_end":43378,"line_start":1333,"line_end":1333,"column_start":19,"column_end":31,"is_primary":true,"text":[{"text":"\t\t\t\t\tif M::BITS > T::Mem::BITS {","highlight_start":19,"highlight_end":31}],"label":"expected type parameter `M`, found `u8`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":42688,"byte_end":42689,"line_start":1304,"line_end":1304,"column_start":14,"column_end":15,"is_primary":false,"text":[{"text":"\tfn store_be<M>(&mut self, mut value: M)","highlight_start":14,"highlight_end":15}],"label":"this type parameter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected type parameter `M`\n             found type `u8`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:1333:19\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1304\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    fn store_be<M>(&mut self, mut value: M)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis type parameter\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1333\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    if M::BITS > T::Mem::BITS {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected type parameter `M`, found `u8`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected type parameter `\u001b[0m\u001b[0m\u001b[1mM\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m                          found type `\u001b[0m\u001b[0m\u001b[1mu8\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":45312,"byte_end":45316,"line_start":1438,"line_end":1438,"column_start":16,"column_end":20,"is_primary":true,"text":[{"text":"\tif !(1 ..= M::BITS as usize).contains(&len) {","highlight_start":16,"highlight_end":20}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":45309,"byte_end":45316,"line_start":1438,"line_end":1438,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"\tif !(1 ..= M::BITS as usize).contains(&len) {","highlight_start":13,"highlight_end":20}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":45309,"byte_end":45316,"line_start":1438,"line_end":1438,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"\tif !(1 ..= M::BITS as usize).contains(&len) {","highlight_start":13,"highlight_end":20}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:1438:16\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1438\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    if !(1 ..= M::BITS as usize).contains(&len) {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1438\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    if !(1 ..= BitMemory::BITS as usize).contains(&len) {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1438\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    if !(1 ..= IsNumber::BITS as usize).contains(&len) {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":45416,"byte_end":45420,"line_start":1442,"line_end":1442,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"\t\t\tM::BITS,","highlight_start":7,"highlight_end":11}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":45413,"byte_end":45420,"line_start":1442,"line_end":1442,"column_start":4,"column_end":11,"is_primary":true,"text":[{"text":"\t\t\tM::BITS,","highlight_start":4,"highlight_end":11}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs","byte_start":45413,"byte_end":45420,"line_start":1442,"line_end":1442,"column_start":4,"column_end":11,"is_primary":true,"text":[{"text":"\t\t\tM::BITS,","highlight_start":4,"highlight_end":11}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/field.rs:1442:7\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1442\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            M::BITS,\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1442\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            BitMemory::BITS,\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1442\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            IsNumber::BITS,\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":4651,"byte_end":4655,"line_start":144,"line_end":144,"column_start":18,"column_end":22,"is_primary":true,"text":[{"text":"\t\tif value >= R::BITS {","highlight_start":18,"highlight_end":22}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":4648,"byte_end":4655,"line_start":144,"line_end":144,"column_start":15,"column_end":22,"is_primary":true,"text":[{"text":"\t\tif value >= R::BITS {","highlight_start":15,"highlight_end":22}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":4648,"byte_end":4655,"line_start":144,"line_end":144,"column_start":15,"column_end":22,"is_primary":true,"text":[{"text":"\t\tif value >= R::BITS {","highlight_start":15,"highlight_end":22}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs:144:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        if value >= R::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        if value >= BitMemory::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        if value >= IsNumber::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":5398,"byte_end":5402,"line_start":171,"line_end":171,"column_start":15,"column_end":19,"is_primary":true,"text":[{"text":"\t\t\tvalue < R::BITS,","highlight_start":15,"highlight_end":19}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":5395,"byte_end":5402,"line_start":171,"line_end":171,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"\t\t\tvalue < R::BITS,","highlight_start":12,"highlight_end":19}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":5395,"byte_end":5402,"line_start":171,"line_end":171,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"\t\t\tvalue < R::BITS,","highlight_start":12,"highlight_end":19}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs:171:15\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m171\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            value < R::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m171\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            value < BitMemory::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m171\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            value < IsNumber::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":5467,"byte_end":5471,"line_start":174,"line_end":174,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"\t\t\tR::BITS,","highlight_start":7,"highlight_end":11}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":5464,"byte_end":5471,"line_start":174,"line_end":174,"column_start":4,"column_end":11,"is_primary":true,"text":[{"text":"\t\t\tR::BITS,","highlight_start":4,"highlight_end":11}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":5464,"byte_end":5471,"line_start":174,"line_end":174,"column_start":4,"column_end":11,"is_primary":true,"text":[{"text":"\t\t\tR::BITS,","highlight_start":4,"highlight_end":11}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs:174:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            R::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            BitMemory::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m174\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            IsNumber::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":6392,"byte_end":6396,"line_start":212,"line_end":212,"column_start":15,"column_end":19,"is_primary":true,"text":[{"text":"\t\t\tnext == R::BITS,","highlight_start":15,"highlight_end":19}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":6389,"byte_end":6396,"line_start":212,"line_end":212,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"\t\t\tnext == R::BITS,","highlight_start":12,"highlight_end":19}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":6389,"byte_end":6396,"line_start":212,"line_end":212,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"\t\t\tnext == R::BITS,","highlight_start":12,"highlight_end":19}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs:212:15\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            next == R::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            next == BitMemory::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            next == IsNumber::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":11177,"byte_end":11181,"line_start":358,"line_end":358,"column_start":16,"column_end":20,"is_primary":true,"text":[{"text":"\t\t\tif (0 .. R::BITS as isize).contains(&far) {","highlight_start":16,"highlight_end":20}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":11174,"byte_end":11181,"line_start":358,"line_end":358,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"\t\t\tif (0 .. R::BITS as isize).contains(&far) {","highlight_start":13,"highlight_end":20}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":11174,"byte_end":11181,"line_start":358,"line_end":358,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"\t\t\tif (0 .. R::BITS as isize).contains(&far) {","highlight_start":13,"highlight_end":20}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs:358:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m358\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            if (0 .. R::BITS as isize).contains(&far) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m358\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            if (0 .. BitMemory::BITS as isize).contains(&far) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m358\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            if (0 .. IsNumber::BITS as isize).contains(&far) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":14669,"byte_end":14673,"line_start":483,"line_end":483,"column_start":16,"column_end":20,"is_primary":true,"text":[{"text":"\t\t\tvalue >= R::BITS,","highlight_start":16,"highlight_end":20}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":14666,"byte_end":14673,"line_start":483,"line_end":483,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"\t\t\tvalue >= R::BITS,","highlight_start":13,"highlight_end":20}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":14666,"byte_end":14673,"line_start":483,"line_end":483,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"\t\t\tvalue >= R::BITS,","highlight_start":13,"highlight_end":20}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs:483:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m483\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            value >= R::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m483\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            value >= BitMemory::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m483\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            value >= IsNumber::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":14737,"byte_end":14741,"line_start":486,"line_end":486,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"\t\t\tR::BITS","highlight_start":7,"highlight_end":11}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":14734,"byte_end":14741,"line_start":486,"line_end":486,"column_start":4,"column_end":11,"is_primary":true,"text":[{"text":"\t\t\tR::BITS","highlight_start":4,"highlight_end":11}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":14734,"byte_end":14741,"line_start":486,"line_end":486,"column_start":4,"column_end":11,"is_primary":true,"text":[{"text":"\t\t\tR::BITS","highlight_start":4,"highlight_end":11}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs:486:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m486\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            R::BITS\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m486\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            BitMemory::BITS\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m486\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            IsNumber::BITS\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":15386,"byte_end":15390,"line_start":519,"line_end":519,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"\t\t\tR::BITS","highlight_start":7,"highlight_end":11}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":15383,"byte_end":15390,"line_start":519,"line_end":519,"column_start":4,"column_end":11,"is_primary":true,"text":[{"text":"\t\t\tR::BITS","highlight_start":4,"highlight_end":11}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":15383,"byte_end":15390,"line_start":519,"line_end":519,"column_start":4,"column_end":11,"is_primary":true,"text":[{"text":"\t\t\tR::BITS","highlight_start":4,"highlight_end":11}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs:519:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m519\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            R::BITS\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m519\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            BitMemory::BITS\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m519\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            IsNumber::BITS\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":17255,"byte_end":17259,"line_start":580,"line_end":580,"column_start":11,"column_end":15,"is_primary":true,"text":[{"text":"\t\tend: R::BITS,","highlight_start":11,"highlight_end":15}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":17252,"byte_end":17259,"line_start":580,"line_end":580,"column_start":8,"column_end":15,"is_primary":true,"text":[{"text":"\t\tend: R::BITS,","highlight_start":8,"highlight_end":15}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":17252,"byte_end":17259,"line_start":580,"line_end":580,"column_start":8,"column_end":15,"is_primary":true,"text":[{"text":"\t\tend: R::BITS,","highlight_start":8,"highlight_end":15}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs:580:11\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m580\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        end: R::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m580\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        end: BitMemory::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m580\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        end: IsNumber::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":17899,"byte_end":17903,"line_start":604,"line_end":604,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"\t\tif value > R::BITS {","highlight_start":17,"highlight_end":21}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":17896,"byte_end":17903,"line_start":604,"line_end":604,"column_start":14,"column_end":21,"is_primary":true,"text":[{"text":"\t\tif value > R::BITS {","highlight_start":14,"highlight_end":21}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":17896,"byte_end":17903,"line_start":604,"line_end":604,"column_start":14,"column_end":21,"is_primary":true,"text":[{"text":"\t\tif value > R::BITS {","highlight_start":14,"highlight_end":21}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs:604:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m604\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        if value > R::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m604\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        if value > BitMemory::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m604\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        if value > IsNumber::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":18625,"byte_end":18629,"line_start":631,"line_end":631,"column_start":16,"column_end":20,"is_primary":true,"text":[{"text":"\t\t\tvalue <= R::BITS,","highlight_start":16,"highlight_end":20}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":18622,"byte_end":18629,"line_start":631,"line_end":631,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"\t\t\tvalue <= R::BITS,","highlight_start":13,"highlight_end":20}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":18622,"byte_end":18629,"line_start":631,"line_end":631,"column_start":13,"column_end":20,"is_primary":true,"text":[{"text":"\t\t\tvalue <= R::BITS,","highlight_start":13,"highlight_end":20}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs:631:16\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m631\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            value <= R::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m631\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            value <= BitMemory::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m631\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            value <= IsNumber::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":18693,"byte_end":18697,"line_start":634,"line_end":634,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"\t\t\tR::BITS,","highlight_start":7,"highlight_end":11}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":18690,"byte_end":18697,"line_start":634,"line_end":634,"column_start":4,"column_end":11,"is_primary":true,"text":[{"text":"\t\t\tR::BITS,","highlight_start":4,"highlight_end":11}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":18690,"byte_end":18697,"line_start":634,"line_end":634,"column_start":4,"column_end":11,"is_primary":true,"text":[{"text":"\t\t\tR::BITS,","highlight_start":4,"highlight_end":11}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs:634:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m634\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            R::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m634\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            BitMemory::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m634\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            IsNumber::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":20998,"byte_end":21002,"line_start":712,"line_end":712,"column_start":26,"column_end":30,"is_primary":true,"text":[{"text":"\t\tlet bits_in_head = (R::BITS - head) as usize;","highlight_start":26,"highlight_end":30}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":20995,"byte_end":21002,"line_start":712,"line_end":712,"column_start":23,"column_end":30,"is_primary":true,"text":[{"text":"\t\tlet bits_in_head = (R::BITS - head) as usize;","highlight_start":23,"highlight_end":30}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":20995,"byte_end":21002,"line_start":712,"line_end":712,"column_start":23,"column_end":30,"is_primary":true,"text":[{"text":"\t\tlet bits_in_head = (R::BITS - head) as usize;","highlight_start":23,"highlight_end":30}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs:712:26\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m712\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let bits_in_head = (R::BITS - head) as usize;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m712\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let bits_in_head = (BitMemory::BITS - head) as usize;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m712\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        let bits_in_head = (IsNumber::BITS - head) as usize;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":23805,"byte_end":23809,"line_start":813,"line_end":813,"column_start":18,"column_end":22,"is_primary":true,"text":[{"text":"\t\tif value >= R::BITS {","highlight_start":18,"highlight_end":22}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":23802,"byte_end":23809,"line_start":813,"line_end":813,"column_start":15,"column_end":22,"is_primary":true,"text":[{"text":"\t\tif value >= R::BITS {","highlight_start":15,"highlight_end":22}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":23802,"byte_end":23809,"line_start":813,"line_end":813,"column_start":15,"column_end":22,"is_primary":true,"text":[{"text":"\t\tif value >= R::BITS {","highlight_start":15,"highlight_end":22}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs:813:18\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m813\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        if value >= R::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m813\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        if value >= BitMemory::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m813\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        if value >= IsNumber::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":24442,"byte_end":24446,"line_start":838,"line_end":838,"column_start":15,"column_end":19,"is_primary":true,"text":[{"text":"\t\t\tvalue < R::BITS,","highlight_start":15,"highlight_end":19}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":24439,"byte_end":24446,"line_start":838,"line_end":838,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"\t\t\tvalue < R::BITS,","highlight_start":12,"highlight_end":19}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":24439,"byte_end":24446,"line_start":838,"line_end":838,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"\t\t\tvalue < R::BITS,","highlight_start":12,"highlight_end":19}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs:838:15\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m838\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            value < R::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m838\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            value < BitMemory::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m838\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            value < IsNumber::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":24514,"byte_end":24518,"line_start":841,"line_end":841,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"\t\t\tR::BITS,","highlight_start":7,"highlight_end":11}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":24511,"byte_end":24518,"line_start":841,"line_end":841,"column_start":4,"column_end":11,"is_primary":true,"text":[{"text":"\t\t\tR::BITS,","highlight_start":4,"highlight_end":11}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":24511,"byte_end":24518,"line_start":841,"line_end":841,"column_start":4,"column_end":11,"is_primary":true,"text":[{"text":"\t\t\tR::BITS,","highlight_start":4,"highlight_end":11}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs:841:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m841\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            R::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m841\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            BitMemory::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m841\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            IsNumber::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":28588,"byte_end":28592,"line_start":997,"line_end":997,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"\t\t\tR::BITS as usize,","highlight_start":7,"highlight_end":11}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":28585,"byte_end":28592,"line_start":997,"line_end":997,"column_start":4,"column_end":11,"is_primary":true,"text":[{"text":"\t\t\tR::BITS as usize,","highlight_start":4,"highlight_end":11}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":28585,"byte_end":28592,"line_start":997,"line_end":997,"column_start":4,"column_end":11,"is_primary":true,"text":[{"text":"\t\t\tR::BITS as usize,","highlight_start":4,"highlight_end":11}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs:997:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m997\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            R::BITS as usize,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m997\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            BitMemory::BITS as usize,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m997\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            IsNumber::BITS as usize,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":29305,"byte_end":29309,"line_start":1028,"line_end":1028,"column_start":40,"column_end":44,"is_primary":true,"text":[{"text":"\t\twrite!(fmt, \"{:0>1$b}\", self.sel, R::BITS as usize)","highlight_start":40,"highlight_end":44}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":29302,"byte_end":29309,"line_start":1028,"line_end":1028,"column_start":37,"column_end":44,"is_primary":true,"text":[{"text":"\t\twrite!(fmt, \"{:0>1$b}\", self.sel, R::BITS as usize)","highlight_start":37,"highlight_end":44}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":29302,"byte_end":29309,"line_start":1028,"line_end":1028,"column_start":37,"column_end":44,"is_primary":true,"text":[{"text":"\t\twrite!(fmt, \"{:0>1$b}\", self.sel, R::BITS as usize)","highlight_start":37,"highlight_end":44}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs:1028:40\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1028\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        write!(fmt, \"{:0>1$b}\", self.sel, R::BITS as usize)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1028\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        write!(fmt, \"{:0>1$b}\", self.sel, BitMemory::BITS as usize)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1028\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        write!(fmt, \"{:0>1$b}\", self.sel, IsNumber::BITS as usize)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":32579,"byte_end":32583,"line_start":1168,"line_end":1168,"column_start":41,"column_end":45,"is_primary":true,"text":[{"text":"\t\twrite!(fmt, \"{:0>1$b}\", self.mask, R::BITS as usize)","highlight_start":41,"highlight_end":45}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":32576,"byte_end":32583,"line_start":1168,"line_end":1168,"column_start":38,"column_end":45,"is_primary":true,"text":[{"text":"\t\twrite!(fmt, \"{:0>1$b}\", self.mask, R::BITS as usize)","highlight_start":38,"highlight_end":45}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs","byte_start":32576,"byte_end":32583,"line_start":1168,"line_end":1168,"column_start":38,"column_end":45,"is_primary":true,"text":[{"text":"\t\twrite!(fmt, \"{:0>1$b}\", self.mask, R::BITS as usize)","highlight_start":38,"highlight_end":45}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/index.rs:1168:41\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1168\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        write!(fmt, \"{:0>1$b}\", self.mask, R::BITS as usize)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1168\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        write!(fmt, \"{:0>1$b}\", self.mask, BitMemory::BITS as usize)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1168\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        write!(fmt, \"{:0>1$b}\", self.mask, IsNumber::BITS as usize)\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1660,"byte_end":1664,"line_start":47,"line_end":47,"column_start":25,"column_end":29,"is_primary":true,"text":[{"text":"\tconst INDX: u8 = Self::BITS.trailing_zeros() as u8;","highlight_start":25,"highlight_end":29}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1654,"byte_end":1664,"line_start":47,"line_end":47,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"\tconst INDX: u8 = Self::BITS.trailing_zeros() as u8;","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1654,"byte_end":1664,"line_start":47,"line_end":47,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"\tconst INDX: u8 = Self::BITS.trailing_zeros() as u8;","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:47:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const INDX: u8 = Self::BITS.trailing_zeros() as u8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const INDX: u8 = BitMemory::BITS.trailing_zeros() as u8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const INDX: u8 = IsNumber::BITS.trailing_zeros() as u8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1866,"byte_end":1870,"line_start":51,"line_end":51,"column_start":25,"column_end":29,"is_primary":true,"text":[{"text":"\tconst MASK: u8 = Self::BITS - 1;","highlight_start":25,"highlight_end":29}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1860,"byte_end":1870,"line_start":51,"line_end":51,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"\tconst MASK: u8 = Self::BITS - 1;","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1860,"byte_end":1870,"line_start":51,"line_end":51,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"\tconst MASK: u8 = Self::BITS - 1;","highlight_start":19,"highlight_end":29}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:51:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m51\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const MASK: u8 = Self::BITS - 1;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m51\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const MASK: u8 = BitMemory::BITS - 1;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m51\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const MASK: u8 = IsNumber::BITS - 1;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/order.rs","byte_start":9426,"byte_end":9430,"line_start":291,"line_end":291,"column_start":15,"column_end":19,"is_primary":true,"text":[{"text":"\t\tif ct == R::BITS {","highlight_start":15,"highlight_end":19}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/order.rs","byte_start":9423,"byte_end":9430,"line_start":291,"line_end":291,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"\t\tif ct == R::BITS {","highlight_start":12,"highlight_end":19}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/order.rs","byte_start":9423,"byte_end":9430,"line_start":291,"line_end":291,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"\t\tif ct == R::BITS {","highlight_start":12,"highlight_end":19}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/order.rs:291:15\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m291\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        if ct == R::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m291\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        if ct == BitMemory::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m291\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        if ct == IsNumber::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/order.rs","byte_start":10898,"byte_end":10902,"line_start":339,"line_end":339,"column_start":15,"column_end":19,"is_primary":true,"text":[{"text":"\t\tif ct == R::BITS {","highlight_start":15,"highlight_end":19}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/order.rs","byte_start":10895,"byte_end":10902,"line_start":339,"line_end":339,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"\t\tif ct == R::BITS {","highlight_start":12,"highlight_end":19}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/order.rs","byte_start":10895,"byte_end":10902,"line_start":339,"line_end":339,"column_start":12,"column_end":19,"is_primary":true,"text":[{"text":"\t\tif ct == R::BITS {","highlight_start":12,"highlight_end":19}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/order.rs:339:15\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m339\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        if ct == R::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m339\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        if ct == BitMemory::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m339\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        if ct == IsNumber::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/order.rs","byte_start":14048,"byte_end":14052,"line_start":450,"line_end":450,"column_start":19,"column_end":23,"is_primary":true,"text":[{"text":"\tfor n in 0 .. R::BITS {","highlight_start":19,"highlight_end":23}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/order.rs","byte_start":14045,"byte_end":14052,"line_start":450,"line_end":450,"column_start":16,"column_end":23,"is_primary":true,"text":[{"text":"\tfor n in 0 .. R::BITS {","highlight_start":16,"highlight_end":23}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/order.rs","byte_start":14045,"byte_end":14052,"line_start":450,"line_end":450,"column_start":16,"column_end":23,"is_primary":true,"text":[{"text":"\tfor n in 0 .. R::BITS {","highlight_start":16,"highlight_end":23}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/order.rs:450:19\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m450\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    for n in 0 .. R::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m450\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    for n in 0 .. BitMemory::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m450\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    for n in 0 .. IsNumber::BITS {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/order.rs","byte_start":14478,"byte_end":14482,"line_start":469,"line_end":469,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"\t\t\tpos.value() < R::BITS,","highlight_start":21,"highlight_end":25}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/order.rs","byte_start":14475,"byte_end":14482,"line_start":469,"line_end":469,"column_start":18,"column_end":25,"is_primary":true,"text":[{"text":"\t\t\tpos.value() < R::BITS,","highlight_start":18,"highlight_end":25}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/order.rs","byte_start":14475,"byte_end":14482,"line_start":469,"line_end":469,"column_start":18,"column_end":25,"is_primary":true,"text":[{"text":"\t\t\tpos.value() < R::BITS,","highlight_start":18,"highlight_end":25}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/order.rs:469:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m469\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            pos.value() < R::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m469\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            pos.value() < BitMemory::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m469\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            pos.value() < IsNumber::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"multiple applicable items in scope","code":{"code":"E0034","explanation":"The compiler doesn't know what method to call because more than one method\nhas the same prototype.\n\nErroneous code example:\n\n```compile_fail,E0034\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // error, which foo() to call?\n}\n```\n\nTo avoid this error, you have to keep only one of them and remove the others.\nSo let's take our example and fix it:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\n\nfn main() {\n    Test::foo() // and now that's good!\n}\n```\n\nHowever, a better solution would be using fully explicit naming of type and\ntrait:\n\n```\nstruct Test;\n\ntrait Trait1 {\n    fn foo();\n}\n\ntrait Trait2 {\n    fn foo();\n}\n\nimpl Trait1 for Test { fn foo() {} }\nimpl Trait2 for Test { fn foo() {} }\n\nfn main() {\n    <Test as Trait1>::foo()\n}\n```\n\nOne last example:\n\n```\ntrait F {\n    fn m(&self);\n}\n\ntrait G {\n    fn m(&self);\n}\n\nstruct X;\n\nimpl F for X { fn m(&self) { println!(\"I am F\"); } }\nimpl G for X { fn m(&self) { println!(\"I am G\"); } }\n\nfn main() {\n    let f = X;\n\n    F::m(&f); // it displays \"I am F\"\n    G::m(&f); // it displays \"I am G\"\n}\n```\n"},"level":"error","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/order.rs","byte_start":14673,"byte_end":14677,"line_start":476,"line_end":476,"column_start":7,"column_end":11,"is_primary":true,"text":[{"text":"\t\t\tR::BITS,","highlight_start":7,"highlight_end":11}],"label":"multiple `BITS` found","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"candidate #1 is defined in the trait `BitMemory`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs","byte_start":1507,"byte_end":1557,"line_start":44,"line_end":44,"column_start":2,"column_end":52,"is_primary":true,"text":[{"text":"\tconst BITS: u8 = mem::size_of::<Self>() as u8 * 8;","highlight_start":2,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"candidate #2 is defined in the trait `IsNumber`","code":null,"level":"note","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs","byte_start":3287,"byte_end":3303,"line_start":144,"line_end":144,"column_start":2,"column_end":18,"is_primary":true,"text":[{"text":"\tconst BITS: u32;","highlight_start":2,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #1","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/order.rs","byte_start":14670,"byte_end":14677,"line_start":476,"line_end":476,"column_start":4,"column_end":11,"is_primary":true,"text":[{"text":"\t\t\tR::BITS,","highlight_start":4,"highlight_end":11}],"label":null,"suggested_replacement":"BitMemory::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"disambiguate the associated constant for candidate #2","code":null,"level":"help","spans":[{"file_name":"/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/order.rs","byte_start":14670,"byte_end":14677,"line_start":476,"line_end":476,"column_start":4,"column_end":11,"is_primary":true,"text":[{"text":"\t\t\tR::BITS,","highlight_start":4,"highlight_end":11}],"label":null,"suggested_replacement":"IsNumber::BITS","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0034]\u001b[0m\u001b[0m\u001b[1m: multiple applicable items in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/order.rs:476:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m476\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            R::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmultiple `BITS` found\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #1 is defined in the trait `BitMemory`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.20.1/src/mem.rs:44:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u8 = mem::size_of::<Self>() as u8 * 8;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: candidate #2 is defined in the trait `IsNumber`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/iamkhalifaMBA/.cargo/registry/src/github.com-1ecc6299db9ec823/funty-1.2.0/src/lib.rs:144:2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    const BITS: u32;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m476\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            BitMemory::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: disambiguate the associated constant for candidate #2\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m476\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            IsNumber::BITS,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"aborting due to 60 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 60 previous errors\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0034, E0308.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0034, E0308.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0034`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0034`.\u001b[0m\n"}
